---
title: "번들러에 대해서"
date: "2025-01-11"
tags: ["bundler", "번들러"]
category:
  main: "dev"
  sub: ""
thumbnail: "/images/번들러에 대해서/thumbnail.webp"
---

# 번들러

번들러는 웹 애플리케이션 개발에서 사용되는 도구로, 여러 파일을 하나의 번들 파일로 묶어주는 역할ㅇ르 한다. 이를 통해 애플리케이션의 성능을 최적화하고, 배포 및 관리가 쉬워진다.

## 번들러 기능

### 모듈 번들링

- 여러 파일을 하나의 파일로 묶어준다
- import나 require로 가져온 파일들을 묶어 브라우저에서 사용할 수 있게 변환한다.
- 브라우저에서 네트워크 요청을 줄여 로드 속도를 향상 시킨다.

### 파일 트랜스 파일링

- 최신 자바스크립트 문법을 오래된 브라우저에서도 동작할 수 있도록 해준다.
- Babel과 같은 도구를 함께 사용한다.

### 코드 분할

- 큰 애플리케이션을 작게 나누어 필요한 부분만 로드한다.
- 초기 로드 시간을 줄이고, 페이지 전환 시 필요한 코드만 로드한다.

### 자원 최적화

- 사용하지 않는 리소스를 제거하거나, 파일을 압축한다.

### 개발 편의성 향상

- HMR: 코드 수정시 브라우저를 새로 고침하지 않고 변경 사항을 즉시 반영한다.
- 로컬 서버 실행, 오류 디버깅 등의 기능을 제공한다.

# Webpack

Webpack은 대규모 프로젝트와 복잡한 애플리케이션에서 널리 사용된. 그러나 현대적인 번들러인 Vite와 Parcel의 등장으로, 작은 규모의 프로젝트나 빠른 개발 환경에서는 Webpack이 덜 사용된다.

## 등장 배경

Webpack은 2012년에 처음 등장했다. 2012년쯤에는 SPA가 대중화되기 시작하면서 여러 자원들이 복잡하게 얽히기 시작했다. 이전에는 js 파일이 전역 스코프에 의존하면서 코드 충돌과 관리에 어려움이 있었다. 하지만 Webpack은 다양한 모듈 시스템을 지원하며, 의존성을 체계적으로 관리할 수 있게 했다.

## Webpack의 주요 컨셉

Webpack은 웹 애플리케이션의 모듈화와 최적화를 위해 설계된 번들러로, 다양한 자원을 묶어서 브라우저에서 효율적으로 사용할 수 있도록 변환합니다.

### 주요 컨셉

1. 모듈(Module):
   - Webpack은 모든 파일을 모듈로 간주한다.
   - 자바스크립트의 ==(파랑)import==와 ==(파랑)require== 문을 분석하여 의존성 그래프를 생성하고, 이를 기반으로 번들링을 수행한다.
2. 엔트리(Entry):
   - 애플리케이션의 진입점으로, Webpack은 이 파일에서부터 의존성을 추적해 필요한 자원들을 번들링한다.
3. 출력(Output):
   - 번들링 결과물을 저장할 파일과 경로를 정의한다.
4. 로더(Loader):
   - Webpack은 기본적으로 JavaScript 파일만 이해할 수 있으므로, 다른 파일(CSS, 이미지, SCSS 등)을 처리하려면 로더가 필요하다.
   - 예: ==(파랑)css-loader==로 CSS 파일을 처리하거나, ==(파랑)babel-loader==로 최신 JavaScript를 변환.
5. 플러그인(Plugin):
   - 번들링 과정의 세부적인 작업(압축, 최적화 등)을 처리한다.
   - 예: HtmlWebpackPlugin으로 HTML 파일 자동 생성, TerserPlugin으로 코드 압축.
6. 코드 분할(Code Splitting):
   - Webpack은 큰 애플리케이션을 작은 청크(Chunk)로 나눠, 필요한 순간에만 로드하도록 지원한다.
   - 초기 로딩 속도를 개선.

## Webpack의 장점

1. 모든 파일을 모듈화:
   - CSS, 이미지, 폰트 등 모든 리소스를 모듈로 처리.
   - 다양한 로더를 통해 여러 형식의 파일을 통합적으로 관리.
2. 강력한 확장성:
   - 플러그인을 통해 번들링 과정에 다양한 기능 추가 가능.
   - 예: HtmlWebpackPlugin, TerserPlugin
3. 코드 최적화:
   - Tree Shaking: 사용하지 않는 코드를 제거해 번들 크기 최소화.
   - 코드 분할(Code Splitting): 초기 로딩 속도 개선.
4. 커뮤니티 지원:
   - 널리 사용되며, 관련 문서와 플러그인이 풍부.
5. 대규모 애플리케이션에 적합:
   - 복잡한 의존성을 가진 대규모 프로젝트에서도 안정적으로 작동.

## Webpack의 단점

1. 설정 복잡성:
   - 유연성이 큰 만큼 설정이 복잡할 수 있음.
   - 단순한 프로젝트에서는 초기 설정에 많은 시간이 소요.
2. 빌드 속도:
   - 빌드 시간이 다른 번들러(Vite, Parcel)에 비해 느릴 수 있음.
   - 해결책: Webpack 5에서는 캐싱 및 멀티코어 활용을 통해 빌드 속도가 개선됨.
3. 러닝 커브:
   - 초보자에게는 로더와 플러그인 설정이 어려울 수 있음.

# Vite

## 등장 배경

Vite는 2020년에 처음 발표됐다. Vite는 기존 번들러(Webpack, Parcel 등)가 대규모 프로젝트에서 느린 빌드 및 HMR 성능 문제를 해결하기 위해 등장했다. 특히 최신 브라우저가 ES Modules를 지원하면서 이를 활용하여 번들링 없이도 빠른 개발 환경을 제공할 수 있게 되었다.

## Vite의 주요 컨셉

Vite는 빠른 개발 환경과 최적화된 프로덕션 빌드를 제공하기 위해 설계됐다.

### 주요 컨셉

1. ES Module 기반의 개발 서버:
   - 개발 환경에서 브라우저가 ES Module(ESM)을 직접 로드.
   - 초기 빌드 속도가 빠르고, 변경된 파일만 재빌드.
2. 핫 모듈 교체(HMR):
   - 코드 수정 시 변경된 부분만 빠르게 업데이트.
   - Webpack보다 더 빠른 HMR 성능 제공.
3. Rollup 기반 프로덕션 빌드:
   - 개발 중에는 ESM 기반으로 동작하지만, 프로덕션 빌드에서는 Rollup을 사용해 최적화된 번들 생성.
4. 플러그인 생태계:
   - Rollup의 플러그인 시스템과 호환.
   - Vite 전용 플러그인도 풍부.
5. 자동 의존성 최적화:
   - 종속성을 자동으로 캐싱하고, 필요한 패키지만 효율적으로 번들링.

## Vite의 장점

1. 빠른 개발 환경:
   - 초기 빌드 및 HMR 속도가 Webpack보다 월등히 빠름.
2. 간단한 설정:
   - "제로 설정"에 가까운 기본값 제공.
3. Rollup 기반 최적화:
   - Tree Shaking, 코드 분할 등 Rollup의 최적화 기능 활용.
4. 현대적 프레임워크와의 통합:
   - React, Vue, Svelte 등과 잘 통합됨.
5. 경량성:
   - 필요한 모듈만 로드하므로 대규모 프로젝트에서도 성능 유지.

## Vite의 단점

1. 레거시 브라우저 지원:
   - 기본적으로 최신 브라우저(ES Modules 지원)에 초점.
   - IE11 등 레거시 브라우저를 지원하려면 추가 설정 필요.
2. 플러그인 생태계 미성숙:
   - Webpack에 비해 플러그인 생태계가 제한적.
3. 빌드 속도:
   - Rollup 기반이므로 빌드 속도가 Parcel만큼 빠르지는 않을 수 있음.

# Parcel

## 등장 배경

Parcel은 2017년에 발표되었으며, "제로 설정 번들러"로 유명하다. Parcel의 목표는 복잡한 설정 없이 빠르게 프로젝트를 시작할 수 있는 환경을 제공하는 것이다. 자동화된 설정과 높은 사용성을 통해 초보자에게 적합한 번들러로 자리 잡았다.

## Parcel의 주요 컨셉

Parcel은 간단함과 자동화를 중심으로 설계됐다.

### 주요 컨셉

1. 제로 설정(Zero Configuration):
   - 복잡한 설정 없이도 다양한 파일 형식(JS, CSS, 이미지 등)을 자동 처리.
2. 자동화된 플러그인 시스템:
   - 사용자가 별도로 설정하지 않아도, 기본 플러그인으로 다양한 작업을 수행.
3. 빠른 빌드:
   - 멀티코어 프로세싱과 캐싱을 통해 빌드 속도 향상.
4. HMR 지원:
   - 코드 변경 시 브라우저를 새로 고치지 않고 즉시 반영.
5. 코드 분할:
   - Webpack처럼 코드 분할을 지원하여 성능 최적화.

## Parcel의 장점

1. 쉬운 사용:
   - 설정 파일 없이도 동작.
   - 초보자도 쉽게 사용할 수 있음.
2. 빠른 초기 빌드:
   - 자동 설정과 멀티코어 활용으로 빌드 속도 개선.
3. 자동 코드 최적화:
   - Tree Shaking, 코드 분할 등을 자동으로 수행.
4. 다양한 파일 형식 지원:
   - CSS, 이미지, HTML 등 다양한 형식을 기본적으로 처리.

## Parcel의 단점

1. 대규모 프로젝트에서 한계:
   - 복잡한 설정이 필요한 경우 Webpack만큼 유연하지 않음.
2. 플러그인 생태계 제한적:
   - Webpack이나 Rollup처럼 커스터마이징 가능한 플러그인 생태계가 부족.
3. 빌드 크기:
   - Webpack과 비교해 프로덕션 빌드 결과가 더 클 수 있음.

# Rollup

## 등장 배경

Rollup은 2015년에 등장했으며 주로 라이브러리와 패키지 번들링에 최적화된 도구이다. ES Modules를 기본으로 채택했으며, Tree Shaking과 모듈 최적화에 강점을 가지고 있다.

## Rollup의 주요 컨셉

Rollup은 모듈 최적화와 경량화에 중점을 둔 번들러이다.

### 주요 컨셉

1. ES Module 기반:
   - ES Modules를 기본으로 사용하여, 브라우저와 Node.js 환경에서 모두 호환.
2. Tree Shaking:
   - 사용하지 않는 코드를 제거해 번들 크기를 최소화.
3. 다양한 출력 형식:
   - UMD, ESM, CJS 등 다양한 형식으로 번들링 가능.
4. 플러그인 시스템:
   - 간단하고 유연한 플러그인 시스템 제공.
5. 라이브러리 개발에 최적화:
   - React, Vue, Svelte 등과 함께 사용되는 라이브러리 번들링에 적합.

## Rollup의 장점

1. 번들 크기 최소화:
   - Tree Shaking으로 불필요한 코드 제거.
2. 다양한 출력 형식 지원:
   - UMD, ESM 등 여러 형식으로 배포 가능.
3. 간단한 설정:
   - 라이브러리 번들링에 적합한 기본 설정 제공.
4. 경량화:
   - 모듈 최적화와 경량화에 강점.

## Rollup의 단점

1. 애플리케이션 번들링에 부적합:
   - Webpack처럼 큰 애플리케이션에 적합하지 않음.
2. 플러그인 생태계 제한적:
   - Webpack보다 플러그인 생태계가 작음.
3. 초기 설정 필요:
   - Parcel이나 Vite에 비해 설정이 간단하지 않을 수 있음.

# 표로 정리

![번들러 표로 정리](/images/번들러에%20대해서/1.png)

# 번들러 선택에 대한 나의 관점

사실 이 글을 쓰면서 공부하기 전까지는 번들러에 대해 제대로 알지 못했다. 개발할 때는 항상 Vite만 사용해왔기 때문에, 다른 번들러에 대해 깊게 생각해본 적이 없었다. 하지만 이번 기회에 Webpack, Parcel, Rollup 등 다양한 번들러들을 비교하고 학습하면서, 각각의 번들러가 가진 특성과 강점이 프로젝트의 성격에 따라 얼마나 중요한 역할을 하는지 깨닫게 되었다.

프로젝트마다 적합한 번들러를 조화롭게 사용하는 것이 중요하다는 생각이 들었다. 특히, 다음과 같은 기준을 세우게 되었다:

- 큰 프로젝트 → Webpack
- 작은 프로젝트 → Parcel
- 라이브러리 및 패키지 개발 → Rollup
- 빠르고 간단하고 싶을때 → Vite

앞으로는 라이브러리 개발에 대한 욕심을 키워가고 있기 때문에, 조만간 Rollup을 사용할 기회가 있을 것 같다. 지금까지는 Vite에만 의존했지만, 앞으로는 다양한 번들러에 대한 지식을 쌓고, 이를 실제 프로젝트에 적용하며 경험을 넓혀가고 싶다. 특히 Rollup과 Vite는 향후 프로젝트에서 자주 사용할 가능성이 크기 때문에, 이를 깊이 이해하고 활용하는 것이 목표다.

번들러는 단순한 도구 그 이상이다. 이를 적재적소에 사용할 수 있는 개발자가 되는 것이 앞으로의 나의 목표다.
